---
phase: 04-lpc-asset-integration
plan: 01
type: execute
---

<objective>
Complete LPC avatar asset integration so custom avatars render correctly for all players.

Purpose: Enable the avatar customization system to work end-to-end - local player spawns with composed avatar, other players render with their custom avatars, and avatar changes update sprites live.

Output: Working avatar composition pipeline where both local and remote players display correctly composed avatars.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-lpc-asset-integration/04-RESEARCH.md

**Key files:**
@GameBuddiesHub/client/src/services/AvatarCompositor.ts
@GameBuddiesHub/client/src/services/AvatarAssetLoader.ts
@GameBuddiesHub/client/src/game/scenes/Game.ts
@GameBuddiesHub/client/src/game/characters/OtherPlayer.ts
@GameBuddiesHub/client/src/types/avatar.ts

**Existing Implementation:**
- AvatarAssetLoader initialized in Bootstrap scene
- AvatarCompositor initialized in Bootstrap scene
- Game.ts has spawnWithAvatar() for local player
- Game.ts sends JSON.stringify(avatarConfig) to server as character field
- OtherPlayer currently falls back to 'adam' when receiving JSON config

**What works:**
- Local player can spawn with composed avatar (spawnWithAvatar method)
- Asset loading from public/assets/avatars/
- Texture compositing with color tinting
- Animation creation for walk/idle

**What's broken:**
- OtherPlayer doesn't compose avatars (always uses fallback)
- No live update when avatar changes after spawn
- No asset manifest for editor to know available options
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create asset manifest for available customization options</name>
  <files>GameBuddiesHub/client/src/services/AvatarManifest.ts, GameBuddiesHub/client/src/types/avatar.ts</files>
  <action>
Create AvatarManifest service that scans available assets and exposes them for the editor UI.

1. Create AvatarManifest.ts service:
   - Export lists of available options: BODY_TYPES, SKIN_TONES, HAIR_STYLES, TOPS, BOTTOMS, SHOES
   - Each option has: id (matches filename), displayName, hasBackLayer (for hair)
   - Move existing HAIR_STYLES and SKIN_TONES from avatar.ts to manifest
   - Add getAvailableOptions() method returning all categories

2. Update avatar.ts to import from manifest instead of defining inline

The manifest is hardcoded based on files in public/assets/avatars/ - no runtime scanning needed.
Do NOT add complex asset validation or file-existence checks - the assets are static.
  </action>
  <verify>Import AvatarManifest in a test file and log getAvailableOptions() - should return all categories with correct options matching actual asset files</verify>
  <done>AvatarManifest.ts exports complete lists of all available customization options, avatar.ts imports from it</done>
</task>

<task type="auto">
  <name>Task 2: Implement OtherPlayer avatar composition</name>
  <files>GameBuddiesHub/client/src/game/characters/OtherPlayer.ts, GameBuddiesHub/client/src/game/scenes/Game.ts</files>
  <action>
Update OtherPlayer to compose custom avatars when receiving JSON config from server.

1. In Game.ts handlePlayerJoined():
   - When newPlayer.character starts with '{', parse as AvatarConfig
   - Call avatarCompositor.composeAvatar(config) (async)
   - Create OtherPlayer with composed texture key
   - Handle fallback to 'adam' if composition fails

2. In OtherPlayer.ts:
   - Add async factory method createWithAvatar(scene, x, y, config, id, name)
   - This handles the async composition before creating the sprite
   - Keep existing constructor for legacy characters

The challenge is handlePlayerJoined is sync but avatar composition is async. Solution:
   - Create OtherPlayer with placeholder texture initially
   - Start async composition
   - On completion, swap texture using setTexture()

Do NOT block player creation on avatar composition - use placeholder then swap.
  </action>
  <verify>Join room with two browser tabs, customize avatar in one, verify second tab shows custom avatar (not default adam)</verify>
  <done>OtherPlayer renders with composed custom avatars when server sends JSON config, falls back gracefully on error</done>
</task>

<task type="auto">
  <name>Task 3: Add live avatar update for spawned players</name>
  <files>GameBuddiesHub/client/src/game/scenes/Game.ts, GameBuddiesHub/client/src/game/characters/MyPlayer.ts</files>
  <action>
Enable avatar changes to update existing player sprites without respawning.

1. In Game.ts handleAvatarUpdated():
   - If myPlayer already exists, compose new avatar texture
   - Swap myPlayer texture using setTexture()
   - Recreate animations for new texture
   - Send updated config to server

2. In MyPlayer.ts:
   - Add updateTexture(textureKey: string) method
   - Handles swapping texture and updating current animation

3. In OtherPlayer.ts handlePlayerUpdated():
   - Detect when character field changes (new JSON config)
   - Trigger async recomposition and texture swap

This enables the avatar editor preview and future "change outfit" functionality.
Do NOT destroy and recreate player sprites - just swap textures.
  </action>
  <verify>In running game, emit 'avatar:updated' event from console with new config, verify player sprite updates without respawning</verify>
  <done>Avatar changes update existing player sprites live, both local and remote players</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` in GameBuddiesHub/client succeeds without TypeScript errors
- [ ] AvatarManifest exports all customization categories
- [ ] OtherPlayer renders custom avatars (not always adam)
- [ ] Avatar updates swap textures without respawning
- [ ] Legacy character keys still work (backward compatibility)
</verification>

<success_criteria>
- All tasks completed
- Build passes without errors
- Custom avatars render for both local and remote players
- Avatar changes update sprites live
- Fallback to legacy characters works when composition fails
</success_criteria>

<output>
After completion, create `.planning/phases/04-lpc-asset-integration/04-01-SUMMARY.md`:

# Phase 4 Plan 01: LPC Asset Integration Summary

**[One-liner summary of what shipped]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- [File list with descriptions]

## Decisions Made
- [Any decisions and rationale]

## Issues Encountered
- [Problems and resolutions]

## Next Step
Ready for Phase 5: Avatar Editor UI
</output>
